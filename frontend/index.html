<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>StuffChat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap Icons only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg1: #0b1220;
            --bg2: #1b263b;
            --glass: rgba(255, 255, 255, 0.08);
            --glass-strong: rgba(255, 255, 255, 0.12);
            --border: rgba(255, 255, 255, 0.15);
            --text: #e9eef7;
            --text-dim: #b7c1d1;
            --accent: #7aa2ff;
            --accent-2: #4dd4ac;
            --danger: #ff6b6b;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            --radius: 16px;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        body {
            background:
                radial-gradient(1200px 800px at 10% 10%, #14213d 0%, transparent 60%),
                radial-gradient(1200px 800px at 90% 0%, #1e3a8a 0%, transparent 55%),
                radial-gradient(1200px 800px at 70% 90%, #0f766e 0%, transparent 55%),
                linear-gradient(160deg, var(--bg1), var(--bg2));
        }

        .app {
            height: 100%;
            display: flex;
            gap: 16px;
            padding: 16px;
        }

        .glass {
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
        }

        /* Sidebar */
        #sidebar {
            width: 290px;
            min-width: 240px;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 12px;
        }

        .profile {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--glass-strong);
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #31415f;
            overflow: hidden;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block
        }

        .presence-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 6px;
        }

        .presence-online {
            background: #22c55e
        }

        .presence-away {
            background: #fbbf24
        }

        .presence-dnd {
            background: #ef4444
        }

        .presence-invisible {
            background: #9ca3af
        }

        .presence-offline {
            background: #6b7280
        }

        .panel {
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .panel h3 {
            font-size: 14px;
            letter-spacing: .08em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin: 4px 0 10px 0;
        }

        .channels {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 45vh;
            overflow: auto;
        }

        .channel {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            color: var(--text-dim);
        }

        .channel:hover {
            background: var(--glass-strong);
            color: var(--text)
        }

        .channel.active {
            background: linear-gradient(180deg, rgba(122, 162, 255, 0.18), rgba(122, 162, 255, 0.12));
            border-color: rgba(122, 162, 255, 0.35);
            color: var(--text);
        }

        .settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: auto;
        }

        .input,
        .select,
        .button {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            color: var(--text);
            background: rgba(255, 255, 255, 0.06);
        }

        .button {
            background: linear-gradient(180deg, rgba(122, 162, 255, 0.2), rgba(122, 162, 255, 0.14));
            cursor: pointer;
        }

        .button.alt {
            background: rgba(255, 255, 255, 0.06)
        }

        .button.danger {
            background: rgba(255, 107, 107, 0.18);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .row {
            display: flex;
            gap: 8px
        }

        .grow {
            flex: 1
        }

        /* Main */
        #main {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--glass);
        }

        .topbar .name {
            font-weight: 600
        }

        .members {
            font-size: 12px;
            color: var(--text-dim)
        }

        .messages {
            flex: 1;
            min-height: 0;
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--glass);
        }

        .load-older {
            align-self: center;
            margin: 6px 0;
            font-size: 13px;
            color: var(--text-dim);
            cursor: pointer;
            padding: 6px 10px;
            border: 1px dashed var(--border);
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.04);
        }

        .msg {
            display: grid;
            grid-template-columns: 42px 1fr;
            gap: 10px;
            padding: 10px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
        }

        .msg.own {
            background: rgba(77, 212, 172, 0.10);
            border-color: rgba(77, 212, 172, 0.25)
        }

        .msg .meta {
            display: flex;
            align-items: baseline;
            gap: 8px;
            color: var(--text-dim);
            font-size: 12px;
        }

        .msg .content {
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Right side of a message: 2 columns (meta/content on left, tools on right) */
        .msg-right {
            display: grid;
            grid-template-columns: 1fr auto;
            column-gap: 8px;
            row-gap: 6px;
            align-items: start;
        }

        /* Header row: meta on the left */
        .msg-right .meta {
            grid-column: 1 / 2;
        }

        /* Content and attachments span full width below the header */
        .msg-right .content,
        .msg-right .attachment {
            grid-column: 1 / -1;
        }

        /* Tools on the top-right; shown on hover */
        .msg .tools {
            grid-column: 3 / 3;
            align-self: end;
            display: flex;
            gap: 6px;
            visibility: hidden;
        }

        .msg:hover .tools {
            visibility: visible;
        }

        .attachment img {
            max-width: min(420px, 85vw);
            max-height: 260px;
            border-radius: 10px;
            border: 1px solid var(--border);
            display: block;
            margin-top: 6px;
        }

        .attachment video {
            max-width: min(420px, 85vw);
            height: 250px;
            border-radius: 10px;
            border: 1px solid var(--border);
            display: block;
            margin-top: 6px;
            background: #000;
        }

        .inputbar {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--glass);
        }

        .inputbar textarea {
            resize: none;
            height: 48px;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            flex: 1;
        }

        .iconbtn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.06);
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .typing {
            font-size: 12px;
            color: var(--text-dim);
            padding: 0 4px
        }

        /* Auth */
        #authView {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .auth-card {
            width: min(480px, 92vw);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .brand {
            font-weight: 700;
            font-size: 22px;
            display: flex;
            align-items: center;
            gap: 8px
        }

        /* Responsive */
        @media (max-width: 980px) {
            #sidebar {
                position: fixed;
                z-index: 10;
                left: 12px;
                right: 12px;
                top: 12px;
                transform: translateY(-150%);
                transition: transform .25s ease;
            }

            #sidebar.open {
                transform: translateY(0)
            }

            .app {
                padding-top: 76px
            }

            .topbar .left {
                display: flex;
                align-items: center;
                gap: 8px
            }

            .toggle-sidebar {
                display: inline-flex
            }
        }

        @media (min-width: 981px) {
            .toggle-sidebar {
                display: none
            }
        }

        .hint {
            font-size: 12px;
            color: var(--text-dim)
        }

        .error {
            color: var(--danger);
            font-size: 12px
        }

        a {
            color: var(--accent);
            text-decoration: none
        }

        a:hover {
            text-decoration: underline
        }

        .pill {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05)
        }
    </style>
</head>

<body>
    <div id="authView" class="glass auth-card">
        <div class="brand"><i class="bi bi-chat-dots"></i> StuffChat</div>
        <div class="hint">Set your API URL, then register or log in.</div>
        <div class="row">
            <input id="cfgBaseUrl" class="input grow" placeholder="Base URL (e.g. http://localhost:8080)" />
            <button id="btnSaveBaseUrl" class="button" style="width:140px">Save</button>
        </div>
        <div class="panel">
            <h3>Login</h3>
            <div class="row">
                <input id="loginUser" class="input grow" placeholder="Username or email" autocomplete="username" />
            </div>
            <div class="row">
                <input id="loginPass" class="input grow" type="password" placeholder="Password"
                    autocomplete="current-password" />
            </div>
            <div class="row">
                <button id="btnLogin" class="button grow">Login</button>
            </div>
            <div id="loginErr" class="error"></div>
        </div>
        <div class="panel" style="margin-top:8px">
            <h3>Register</h3>
            <div class="row"><input id="regUser" class="input grow" placeholder="Username" autocomplete="username" />
            </div>
            <div class="row"><input id="regEmail" class="input grow" placeholder="Email" autocomplete="email" /></div>
            <div class="row"><input id="regPass" class="input grow" type="password" placeholder="Password (min 8 chars)"
                    autocomplete="new-password" /></div>
            <div class="row"><button id="btnRegister" class="button grow">Create account</button></div>
            <div id="regErr" class="error"></div>
        </div>
    </div>

    <div id="appView" class="app" style="display:none">
        <aside id="sidebar" class="glass">
            <div class="profile">
                <div class="avatar" id="meAvatar"></div>
                <div style="min-width:0">
                    <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap">
                        <div id="meName" style="font-weight:600">—</div>
                        <span id="mePresence" class="presence-dot presence-offline" title="offline"></span>
                    </div>
                    <div id="meEmail" class="hint">—</div>
                </div>
            </div>

            <div class="panel">
                <h3>Channels</h3>
                <div class="channels" id="channels"></div>
                <div class="row" style="margin-top:8px">
                    <input id="newChannelName" class="input grow" placeholder="New channel name" />
                    <button id="btnCreateChannel" class="iconbtn" title="Create">
                        <i class="bi bi-plus-lg"></i>
                    </button>
                </div>
            </div>

            <div class="panel settings">
                <h3>Settings</h3>
                <input id="baseUrl" class="input" placeholder="Base URL (http://host:port)" />
                <div class="row">
                    <select id="presenceSelect" class="select grow" title="Status">
                        <option value="online">Online</option>
                        <option value="away">Away</option>
                        <option value="dnd">Do Not Disturb</option>
                        <option value="invisible">Invisible</option>
                        <option value="offline">Offline</option>
                    </select>
                    <button id="btnHeartbeat" class="iconbtn" title="Send heartbeat"><i
                            class="bi bi-activity"></i></button>
                </div>
                <div class="row">
                    <label class="button alt grow" style="cursor:pointer; text-align:center">
                        <i class="bi bi-image"></i> Change avatar
                        <input id="avatarFile" type="file" accept="image/*" style="display:none" />
                    </label>
                    <button id="btnLogout" class="button danger" style="width:120px">Logout</button>
                </div>
            </div>
        </aside>

        <main id="main">
            <div class="topbar">
                <div class="left">
                    <button class="iconbtn toggle-sidebar" id="btnToggleSidebar" title="Menu"><i
                            class="bi bi-list"></i></button>
                    <div class="name" id="channelName">Select a channel</div>
                </div>
                <div class="members" id="memberInfo">—</div>
            </div>

            <div class="messages" id="messages">
                <!-- Load older -->
            </div>

            <div class="typing" id="typingIndicator" style="display:none">Someone is typing…</div>

            <div class="inputbar">
                <label class="iconbtn" title="Attach file" style="cursor:pointer">
                    <i class="bi bi-paperclip"></i>
                    <input id="attachFile" type="file" style="display:none" />
                </label>
                <textarea id="msgInput" placeholder="Write a message…" disabled></textarea>
                <button id="btnSend" class="iconbtn" title="Send" disabled><i class="bi bi-send-fill"></i></button>
            </div>
        </main>
    </div>

    <script>
        // --- Simple state/store ---
        const store = {
            baseUrl: localStorage.getItem('stuffchat.base_url') || '',
            accessToken: localStorage.getItem('stuffchat.access_token') || '',
            refreshTokenId: localStorage.getItem('stuffchat.refresh_token_id') || '',
            refreshToken: localStorage.getItem('stuffchat.refresh_token') || '',
            user: null,
            ws: null,
            channels: [],
            currentChannelId: null,
            messages: new Map(), // channelId -> array of messages (ascending by created_at)
            oldestMessageId: new Map(), // channelId -> oldest id loaded (for pagination)
            members: new Map(), // channelId -> array of user_ids
            presenceCache: new Map(), // userId -> status
            typingTimers: new Map(), // userId -> timeout
            typingUsers: new Set(), // currently typing in current channel
        };

        // --- Utilities ---
        const $ = sel => document.querySelector(sel);
        const el = (tag, attrs = {}, children = []) => {
            const e = document.createElement(tag);
            Object.entries(attrs).forEach(([k, v]) => {
                if (k === 'class') e.className = v;
                else if (k === 'style') e.style.cssText = v;
                else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.slice(2), v);
                else if (v !== undefined && v !== null) e.setAttribute(k, v);
            });
            (Array.isArray(children) ? children : [children]).forEach(c => {
                if (c === null || c === undefined) return;
                if (typeof c === 'string') e.appendChild(document.createTextNode(c));
                else e.appendChild(c);
            });
            return e;
        };
        const truncateId = id => id ? id.slice(0, 8) : 'unknown';
        const sleep = ms => new Promise(r => setTimeout(r, ms));
        const toWsUrl = (httpUrl) => {
            if (!httpUrl) return '';
            try {
                const u = new URL(httpUrl);
                u.protocol = (u.protocol === 'https:') ? 'wss:' : 'ws:';
                u.pathname = '/ws';
                u.search = '';
                return u.toString();
            } catch { return ''; }
        };
        const presenceClass = status => ({
            online: 'presence-online',
            away: 'presence-away',
            dnd: 'presence-dnd',
            invisible: 'presence-invisible',
            offline: 'presence-offline'
        }[status] || 'presence-offline');

        function saveTokens({ access_token, refresh_token_id, refresh_token }) {
            store.accessToken = access_token;
            store.refreshTokenId = refresh_token_id;
            store.refreshToken = refresh_token;
            localStorage.setItem('stuffchat.access_token', access_token);
            localStorage.setItem('stuffchat.refresh_token_id', refresh_token_id);
            localStorage.setItem('stuffchat.refresh_token', refresh_token);
        }

        async function apiFetch(path, opts = {}, retry = true) {
            if (!store.baseUrl) throw new Error('Base URL not set');
            const headers = new Headers(opts.headers || {});
            headers.set('Content-Type', headers.get('Content-Type') || 'application/json');
            if (store.accessToken) headers.set('Authorization', 'Bearer ' + store.accessToken);
            const res = await fetch(store.baseUrl + path, { ...opts, headers });
            if (res.status === 204) return null;
            if (res.ok) {
                const ct = res.headers.get('Content-Type') || '';
                return ct.includes('application/json') ? res.json() : res.text();
            }
            if (res.status === 401 && retry && store.refreshTokenId && store.refreshToken) {
                const ok = await refreshTokens();
                if (ok) return apiFetch(path, opts, false);
            }
            let errMsg = 'Request failed';
            try { const data = await res.json(); if (data && data.error) errMsg = data.error; } catch { }
            throw new Error(errMsg + ' (' + res.status + ')');
        }

        async function refreshTokens() {
            try {
                const data = await fetch(store.baseUrl + '/api/auth/refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ refresh_token_id: store.refreshTokenId, refresh_token: store.refreshToken })
                }).then(r => r.ok ? r.json() : Promise.reject(r));
                saveTokens(data);
                // reconnect WS with new token
                connectWs(true);
                return true;
            } catch (e) {
                console.warn('Refresh failed', e);
                logout(true);
                return false;
            }
        }

        function setBaseUrl(url) {
            store.baseUrl = url.trim().replace(/\/+$/, '');
            localStorage.setItem('stuffchat.base_url', store.baseUrl);
            $('#baseUrl').value = store.baseUrl;
            $('#cfgBaseUrl').value = store.baseUrl;
        }

        // --- Auth flow ---
        async function doLogin(username_or_email, password) {
            const data = await apiFetch('/api/auth/login', {
                method: 'POST',
                body: JSON.stringify({ username_or_email, password })
            }, false);
            saveTokens(data);
            await bootstrapAfterAuth();
        }
        async function doRegister(username, email, password) {
            const data = await apiFetch('/api/auth/register', {
                method: 'POST',
                body: JSON.stringify({ username, email, password })
            }, false);
            saveTokens(data);
            await bootstrapAfterAuth();
        }
        async function logout(silent = false) {
            try {
                if (store.refreshTokenId) {
                    await apiFetch('/api/auth/logout', { method: 'POST', body: JSON.stringify({ refresh_token_id: store.refreshTokenId }) });
                }
            } catch (e) { if (!silent) alert('Logout error: ' + e.message); }
            localStorage.removeItem('stuffchat.access_token');
            localStorage.removeItem('stuffchat.refresh_token_id');
            localStorage.removeItem('stuffchat.refresh_token');
            store.accessToken = ''; store.refreshTokenId = ''; store.refreshToken = ''; store.user = null;
            if (store.ws) { try { store.ws.close(); } catch { } store.ws = null; }
            $('#appView').style.display = 'none';
            $('#authView').style.display = 'flex';
        }

        async function bootstrapAfterAuth() {
            $('#authView').style.display = 'none';
            $('#appView').style.display = 'flex';
            await loadMe();
            await loadChannels();
            connectWs();
            enableComposer(false);
            heartbeat(); // send initial presence
            presencePollLoop(); // periodic presence refresh for members
        }

        // --- Presence ---
        async function heartbeat() {
            const status = $('#presenceSelect').value || 'online';
            try { await apiFetch('/api/presence/heartbeat', { method: 'POST', body: JSON.stringify({ status }) }); } catch (e) { console.warn('Heartbeat failed', e.message); }
            // reflect my status badge
            const meDot = $('#mePresence');
            meDot.className = 'presence-dot ' + presenceClass(status);
            meDot.title = status;
        }
        setInterval(heartbeat, 30000);

        async function fetchPresenceForUsers(userIds) {
            if (!userIds || userIds.length === 0) return;
            const query = '?ids=' + encodeURIComponent(userIds.join(','));
            try {
                const res = await apiFetch('/api/presence/users' + query);
                res.forEach(p => {
                    store.presenceCache.set(p.user_id, p.status);
                });
                renderMemberInfo();
            } catch (e) { console.warn('Presence fetch failed', e.message); }
        }

        async function presencePollLoop() {
            while (store.accessToken) {
                const members = store.members.get(store.currentChannelId) || [];
                await fetchPresenceForUsers(members);
                await sleep(15000);
            }
        }

        // --- Me/User ---
        async function loadMe() {
            const me = await apiFetch('/api/users/me');
            store.user = me;
            $('#meName').textContent = me.username || 'me';
            $('#meEmail').textContent = me.email || '';
            if (me.avatar_file_id) {
                $('#meAvatar').innerHTML = `<img src="${store.baseUrl}/files/${me.avatar_file_id}" alt="avatar">`;
            } else {
                $('#meAvatar').innerHTML = '';
            }
        }

        async function uploadAvatar(file) {
            const fd = new FormData();
            fd.append('file', file);
            const res = await fetch(store.baseUrl + '/api/users/me/avatar', {
                method: 'PUT',
                headers: store.accessToken ? { 'Authorization': 'Bearer ' + store.accessToken } : {},
                body: fd
            });
            if (!res.ok) {
                let msg = 'Upload failed';
                try { const d = await res.json(); if (d.error) msg = d.error; } catch { }
                throw new Error(msg);
            }
            const data = await res.json();
            if (data && data.avatar_file_id) {
                $('#meAvatar').innerHTML = `<img src="${store.baseUrl}/files/${data.avatar_file_id}" alt="avatar">`;
            }
        }

        // --- Channels ---
        async function loadChannels() {
            const list = await apiFetch('/api/channels');
            store.channels = list;
            renderChannelList();
            // Auto-select first channel
            if (list.length && !store.currentChannelId) {
                selectChannel(list[0].id);
            }
        }

        function renderChannelList() {
            const wrap = $('#channels');
            wrap.innerHTML = '';
            store.channels.forEach(ch => {
                const isActive = ch.id === store.currentChannelId;
                const li = el('div', { class: 'channel' + (isActive ? ' active' : ''), onclick: () => selectChannel(ch.id) }, [
                    el('i', { class: 'bi ' + (ch.is_voice ? 'bi-mic' : 'bi-hash') }),
                    el('div', {}, ch.name)
                ]);
                wrap.appendChild(li);
            });
        }

        async function createChannel(name) {
            if (!name.trim()) return;
            const res = await apiFetch('/api/channels', { method: 'POST', body: JSON.stringify({ name: name.trim(), is_voice: false, is_private: false }) });
            await loadChannels();
            selectChannel(res.id);
            $('#newChannelName').value = '';
        }

        // --- Messages ---
        async function selectChannel(channelId) {
            if (store.currentChannelId && store.ws) {
                store.ws.send(JSON.stringify({ type: 'leave', channel_id: store.currentChannelId }));
            }
            store.currentChannelId = channelId;
            renderChannelList();

            const ch = store.channels.find(c => c.id === channelId);
            $('#channelName').textContent = ch ? '# ' + ch.name : 'Channel';

            // load members
            try {
                const members = await apiFetch(`/api/channels/${channelId}/members`);
                const ids = members.map(m => m.user_id);
                store.members.set(channelId, ids);
                fetchPresenceForUsers(ids);
            } catch (e) { store.members.set(channelId, []); }

            // reset messages state
            store.messages.set(channelId, []);
            store.oldestMessageId.set(channelId, null);
            $('#messages').innerHTML = '';
            addLoadOlderButton();

            // Join WS room
            if (store.ws && store.ws.readyState === 1) {
                store.ws.send(JSON.stringify({ type: 'join', channel_id: channelId }));
            }

            // fetch first page
            await fetchMessagesPage(channelId);

            enableComposer(true);
            $('#msgInput').focus();
        }

        function addLoadOlderButton() {
            const btn = el('div', { class: 'load-older', id: 'loadOlder', onclick: () => loadOlder() }, [
                el('i', { class: 'bi bi-chevron-up' }), ' Load older'
            ]);
            $('#messages').appendChild(btn);
        }

        async function loadOlder() {
            const chan = store.currentChannelId;
            const arr = store.messages.get(chan) || [];
            const before = arr.length ? arr[0].id : null;
            await fetchMessagesPage(chan, before);
        }

        async function fetchMessagesPage(channelId, beforeId = null) {
            let url = `/api/channels/${channelId}/messages?limit=50`;
            if (beforeId) url += '&before=' + encodeURIComponent(beforeId);
            const page = await apiFetch(url);
            // API returns newest-first; we want ascending:
            page.reverse();
            const list = store.messages.get(channelId) || [];
            const isFirstLoad = list.length === 0;
            const atBottom = isScrolledToBottom();

            // Merge while avoiding duplicates
            const have = new Set(list.map(m => m.id));
            const merged = beforeId ? [...page.filter(m => !have.has(m.id)), ...list] : [...list, ...page.filter(m => !have.has(m.id))];
            store.messages.set(channelId, merged);
            if (page.length) {
                store.oldestMessageId.set(channelId, merged[0].id);
            }

            renderMessages(channelId);

            if (isFirstLoad || atBottom) scrollToBottom();
        }

        function renderMessages(channelId) {
            if (channelId !== store.currentChannelId) return;
            const wrap = $('#messages');
            wrap.innerHTML = '';
            addLoadOlderButton();
            const arr = store.messages.get(channelId) || [];
            arr.forEach(msg => {
                wrap.appendChild(renderMessageItem(msg));
            });
        }

        function renderMessageItem(m) {
            const own = (m.user_id === (store.user && store.user.id));
            const avatar = el('div', { class: 'avatar' });
            // We only know my avatar; others unknown in baseline API
            if (own && store.user && store.user.avatar_file_id) {
                avatar.innerHTML = `<img src="${store.baseUrl}/files/${store.user.avatar_file_id}" alt="me">`;
            }
            const meta = el('div', { class: 'meta' }, [
                el('strong', {}, own ? (store.user?.username || 'me') : truncateId(m.user_id)),
                el('span', {}, '•'),
                el('span', {}, new Date(m.created_at || Date.now()).toLocaleString()),
                m.edited_at ? el('span', { class: 'pill' }, 'edited') : null
            ]);
            const content = el('div', { class: 'content' }, m.content || '');
            const attach = (m.file_id) ? renderAttachment(m.file_id) : null;

            const tools = el('div', { class: 'tools' }, []);
            if (own) {
                const editBtn = el('button', { class: 'iconbtn', title: 'Edit', onclick: () => editMessage(m) }, el('i', { class: 'bi bi-pencil' }));
                const delBtn = el('button', { class: 'iconbtn', title: 'Delete', onclick: () => deleteMessage(m) }, el('i', { class: 'bi bi-trash' }));
                tools.append(editBtn, delBtn);
            }

            const right = el('div', { class: 'msg-right' }, [meta, content, attach]);
            const row = el('div', { class: 'msg' + (own ? ' own' : '') }, [
                avatar, right, tools
            ]);
            return row;
        }

        function renderAttachment(fileId) {
            const box = el('div', { class: 'attachment' }, []);
            const url = `${store.baseUrl}/files/${fileId}`;

            // Try to detect content type; fallback path still handles CORS/HEAD-disabled servers
            fetch(url, { method: 'HEAD' })
                .then(res => {
                    const ct = (res.headers.get('Content-Type')).toLowerCase();
                    console.log("Content type of attachment: ", ct);
                    if (ct.startsWith('video/')) {
                        const v = el('video', { src: url, controls: true, preload: 'metadata', playsinline: true });
                        box.appendChild(v);
                    } else if (ct.startsWith('image/')) {
                        const img = new Image();
                        img.onload = () => box.appendChild(img);
                        img.onerror = () => box.appendChild(el('a', { href: url, target: '_blank' }, 'Download attachment'));
                        img.src = url;
                        img.alt = 'attachment';
                    } else {
                        box.appendChild(el('a', { href: url, target: '_blank' }, 'Download attachment'));
                    }
                })
                .catch(() => {
                    // Fallback: try as image; if not, try video; else link
                    console.log("Falling back for attachment");
                    const img = new Image();
                    img.onload = () => box.appendChild(img);
                    img.onerror = () => {
                        const v = el('video', { src: url, controls: true, preload: 'metadata', autoplay: false });
                        v.onerror = () => box.appendChild(el('a', { href: url, target: '_blank' }, 'Download attachment'));
                        box.appendChild(v);
                    };
                    img.src = url;
                    img.alt = 'attachment';
                });

            return box;
        }

        function isScrolledToBottom() {
            const wrap = $('#messages');
            return wrap.scrollHeight - wrap.scrollTop - wrap.clientHeight < 10;
        }
        function scrollToBottom() {
            const wrap = $('#messages');
            wrap.scrollTop = wrap.scrollHeight;
        }

        async function sendMessage() {
            const content = $('#msgInput').value.trim();
            const fileInput = $('#attachFile');
            let file_id = null;

            // Upload first attached file if present
            if (fileInput.files && fileInput.files[0]) {
                const fd = new FormData();
                fd.append('file', fileInput.files[0]);
                const res = await fetch(store.baseUrl + '/api/files', {
                    method: 'POST',
                    headers: store.accessToken ? { 'Authorization': 'Bearer ' + store.accessToken } : {},
                    body: fd
                });
                if (!res.ok) {
                    let msg = 'File upload failed';
                    try { const d = await res.json(); if (d.error) msg = d.error; } catch { }
                    alert(msg);
                    return;
                }
                const data = await res.json();
                file_id = data.file_id;
            }

            if (!content && !file_id) return;
            $('#msgInput').value = '';
            fileInput.value = '';

            try {
                await apiFetch(`/api/channels/${store.currentChannelId}/messages`, {
                    method: 'POST',
                    body: JSON.stringify({ content: content || null, file_id: file_id || null })
                });
                // We rely on message_created event to render; if missed, we could fallback to refetch
            } catch (e) {
                alert('Send failed: ' + e.message);
            }
        }

        async function editMessage(m) {
            const text = prompt('Edit message:', m.content || '');
            if (text === null) return;
            try {
                await apiFetch(`/api/messages/${m.id}`, { method: 'PATCH', body: JSON.stringify({ content: text }) });
                // WS will emit message_edited
            } catch (e) { alert('Edit failed: ' + e.message); }
        }

        async function deleteMessage(m) {
            if (!confirm('Delete this message?')) return;
            try {
                await apiFetch(`/api/messages/${m.id}`, { method: 'DELETE' });
                // WS will emit message_deleted
            } catch (e) { alert('Delete failed: ' + e.message); }
        }

        function enableComposer(enabled) {
            $('#msgInput').disabled = !enabled;
            $('#btnSend').disabled = !enabled;
        }

        // --- WebSocket ---
        function connectWs(reconnect = false) {
            const url = toWsUrl(store.baseUrl);
            if (!url || !store.accessToken) return;
            try {
                if (store.ws) { try { store.ws.close(); } catch { } }
                const ws = new WebSocket(url + '?token=' + encodeURIComponent(store.accessToken));
                store.ws = ws;
                ws.onopen = () => {
                    // Rejoin current channel
                    if (store.currentChannelId) {
                        ws.send(JSON.stringify({ type: 'join', channel_id: store.currentChannelId }));
                    }
                };
                ws.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        handleWsMessage(msg);
                    } catch (e) { console.warn('WS parse error', e) }
                };
                ws.onclose = () => {
                    // Try to reconnect after a delay
                    if (store.accessToken) {
                        setTimeout(() => connectWs(true), 2000);
                    }
                };
            } catch (e) { console.warn('WS connect error', e.message); }
        }

        function handleWsMessage(ev) {
            switch (ev.type) {
                case 'message_created': {
                    const arr = store.messages.get(ev.channel_id) || [];
                    if (!arr.some(m => m.id === ev.id)) {
                        arr.push(ev); // created_at is present; append at end (ascending)
                        store.messages.set(ev.channel_id, arr);
                    }
                    if (ev.channel_id === store.currentChannelId) {
                        const atBottom = isScrolledToBottom();
                        $('#messages').appendChild(renderMessageItem(ev));
                        if (atBottom) scrollToBottom();
                    }
                    break;
                }
                case 'message_edited': {
                    const arr = store.messages.get(ev.channel_id) || [];
                    const m = arr.find(x => x.id === ev.id);
                    if (m) { m.content = ev.content; m.edited_at = ev.edited_at; }
                    if (ev.channel_id === store.currentChannelId) renderMessages(ev.channel_id);
                    break;
                }
                case 'message_deleted': {
                    const arr = store.messages.get(ev.channel_id) || [];
                    const idx = arr.findIndex(x => x.id === ev.id);
                    if (idx >= 0) { arr.splice(idx, 1); }
                    if (ev.channel_id === store.currentChannelId) renderMessages(ev.channel_id);
                    break;
                }
                case 'chat_message': {
                    // Ephemeral echo; show with a distinctive pill
                    if (ev.channel_id === store.currentChannelId) {
                        const pseudo = {
                            id: 'ephemeral-' + Math.random().toString(36).slice(2),
                            channel_id: ev.channel_id,
                            user_id: ev.user_id,
                            content: '[ephemeral] ' + ev.content,
                            created_at: new Date().toISOString()
                        };
                        const atBottom = isScrolledToBottom();
                        $('#messages').appendChild(renderMessageItem(pseudo));
                        if (atBottom) scrollToBottom();
                    }
                    break;
                }
                case 'typing': {
                    if (ev.channel_id !== store.currentChannelId) break;
                    if (ev.started) {
                        store.typingUsers.add(ev.user_id);
                        updateTypingIndicator();
                        // auto-clear after a couple seconds without further events
                        if (store.typingTimers.has(ev.user_id)) clearTimeout(store.typingTimers.get(ev.user_id));
                        store.typingTimers.set(ev.user_id, setTimeout(() => {
                            store.typingUsers.delete(ev.user_id);
                            updateTypingIndicator();
                        }, 3000));
                    } else {
                        store.typingUsers.delete(ev.user_id);
                        updateTypingIndicator();
                    }
                    break;
                }
                case 'pong': break;
                default: break;
            }
        }

        function updateTypingIndicator() {
            const elTip = $('#typingIndicator');
            if (store.typingUsers.size) {
                const sample = [...store.typingUsers][0];
                elTip.textContent = (store.typingUsers.size > 1) ? 'Several people are typing…' : (truncateId(sample) + ' is typing…');
                elTip.style.display = '';
            } else {
                elTip.style.display = 'none';
            }
        }

        function sendTyping(started) {
            if (store.ws && store.ws.readyState === 1 && store.currentChannelId) {
                store.ws.send(JSON.stringify({ type: 'typing', channel_id: store.currentChannelId, started }));
            }
        }

        // --- UI bindings ---
        function renderMemberInfo() {
            const ids = store.members.get(store.currentChannelId) || [];
            const onlineCount = ids.filter(id => (store.presenceCache.get(id) || 'offline') !== 'offline').length;
            $('#memberInfo').textContent = `${ids.length} members • ${onlineCount} online`;
        }

        function bindUI() {
            $('#btnSaveBaseUrl').addEventListener('click', () => setBaseUrl($('#cfgBaseUrl').value));
            $('#baseUrl').addEventListener('change', e => setBaseUrl(e.target.value));

            $('#btnLogin').addEventListener('click', async () => {
                $('#loginErr').textContent = '';
                try { await doLogin($('#loginUser').value, $('#loginPass').value); }
                catch (e) { $('#loginErr').textContent = e.message; }
            });
            $('#btnRegister').addEventListener('click', async () => {
                $('#regErr').textContent = '';
                try { await doRegister($('#regUser').value, $('#regEmail').value, $('#regPass').value); }
                catch (e) { $('#regErr').textContent = e.message; }
            });
            $('#btnLogout').addEventListener('click', () => logout());

            $('#btnCreateChannel').addEventListener('click', () => createChannel($('#newChannelName').value));
            $('#newChannelName').addEventListener('keydown', e => { if (e.key === 'Enter') createChannel($('#newChannelName').value) });

            $('#btnSend').addEventListener('click', sendMessage);
            $('#msgInput').addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                    sendTyping(false);
                } else {
                    sendTyping(true);
                }
            });
            let typingDeb;
            $('#msgInput').addEventListener('input', () => {
                if (typingDeb) clearTimeout(typingDeb);
                typingDeb = setTimeout(() => sendTyping(false), 1000);
            });

            $('#btnHeartbeat').addEventListener('click', heartbeat);

            $('#avatarFile').addEventListener('change', async (e) => {
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                try { await uploadAvatar(f); } catch (err) { alert(err.message); }
                e.target.value = '';
            });

            $('#attachFile').addEventListener('change', () => {
                if ($('#attachFile').files && $('#attachFile').files[0]) {
                    // Visual hint only
                    const name = $('#attachFile').files[0].name;
                    $('#msgInput').placeholder = 'Attached: ' + name;
                } else {
                    $('#msgInput').placeholder = 'Write a message…';
                }
            });

            $('#btnToggleSidebar').addEventListener('click', () => {
                $('#sidebar').classList.toggle('open');
            });

            window.addEventListener('beforeunload', () => {
                if (store.ws) try { store.ws.close(); } catch { }
            });
        }

        // --- Init ---
        async function init() {
            bindUI();
            setBaseUrl(store.baseUrl);
            $('#cfgBaseUrl').value = store.baseUrl;

            if (store.accessToken && store.baseUrl) {
                try {
                    $('#authView').style.display = 'none';
                    $('#appView').style.display = 'flex';
                    await loadMe();
                    await loadChannels();
                    connectWs();
                    heartbeat();
                    presencePollLoop();
                } catch (e) {
                    // If token invalid, go back to auth
                    await refreshTokens().catch(() => logout(true));
                }
            } else {
                $('#authView').style.display = 'flex';
            }
        }

        init();
    </script>
</body>

</html>